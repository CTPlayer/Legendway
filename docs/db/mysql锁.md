## 锁类型
#### 乐观锁和悲观锁

数据库锁从逻辑角度可以分为两类：乐观锁和悲观锁。

* 悲观锁

    悲观锁一般就是我们通常说的数据库层面的锁机制。一般分为表锁和行锁。MyISAM 中只用到表锁，不会有死锁的问题，锁的开销也很小，但是相应的并发能力很差。InnoDB 实现了行级锁和表锁，
    锁的粒度变小了，并发能力变强，但是相应的锁的开销变大，很有可能出现死锁。同时 InnoDB 需要协调这两种锁，算法也变得复杂。
    
    悲观锁按使用性质分类：
    * 共享锁（S 锁）：假设事务 T1 对数据 A 加上共享锁，那么事务 T2 可以读数据 A，不能修改数据 A；
    * 排他锁（X 锁）：假设事务 T1 对数据A加上共享锁，那么事务 T2 不能读数据 A，不能修改数据 A。
    
    悲观锁按作用范围分类包括以下三种：
    * Record Locks：行锁，注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，InnoDB 一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！
    * Gap Locks：间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在 RC 隔离级别下，不会使用间隙锁。这里我对官网补充一下，隔离级别比 RC 低的情况下，也不会使用间隙锁，
      如隔离级别为 RU 时，也不存在间隙锁。当隔离级别为 RR 和 Serializable 时，就会存在间隙锁。
    * Next-Key Locks：这个理解为 Record Lock +索引前面的 Gap Lock。
    
    InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。 InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，
    InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！
    
    **上面这句话有两个注意点：**
    1. 并不是用表锁来实现锁表的操作，而是利用了 Next-Key Locks，也可以理解为是用了行锁+间隙锁来实现锁表的操作!
    2. 注意我上面说的，之所以能够锁表，是通过行锁+间隙锁来实现的。那么，RU 和 RC 都不存在间隙锁，所以上面这种说法在 RU 和 RC 中是不能成立的。因此，该说法只在 RR 和 Serializable 中是成立的。
       如果隔离级别为 RU 和 RC，无论条件列上是否有索引，都不会锁表，只锁行！

* 乐观锁

    相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

    而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。
    读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 

    MVCC 机制是乐观锁的实现。要说明的是，MVCC 的实现没有固定的规范，每个数据库都会有不同的实现方式。
    
## MVCC 机制

MySQL MVCC 机制实现了 Read committed 和 Repeatable Read 隔离级别。如果要实现 Read committed 隔离级别，最简单的方案就是给事务中所有的读操作添加共享锁，所有的写操作添加排他锁。
这样就能够确保所有事务内的读操作都能够读到已经提交了的更新（未提交的更新加了排他锁，因此无法读到）。 

然而直接通过读锁和排他锁实现的 Read committed 隔离级别，并发事务读吞吐量很低。因此，MySQL 通过 MVCC 机制，避免了对于读操作的加锁，并发竞争的概率大大降低，从而提升了并发事务间的读效率。                                                                        

#### 一致性非锁定读

对于 一致性非锁定读（Consistent Nonlocking Reads） 的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，
如果记录的版本小于可见版本，则表示该记录可见。

在 InnoDB 存储引擎中，多版本控制 (multi versioning) 就是对非锁定读的实现。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。
相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)。真是由于这种快照读才使得 DELETE 或 UPDATE 操作无需等待锁的释放，可以直接操作行。

在 Repeatable Read 和 Read Committed 两个隔离级别下，如果是执行普通的 select 语句（不包括 select ... lock in share mode ,select ... for update）则会使用一致性非锁定读（MVCC）。
并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读。

#### 锁定读

如果执行的是下列语句，就是 锁定读（Locking Reads）
* select ... lock in share mode
* select ... for update
* insert、update、delete 操作

在锁定读下，读取的是数据的最新版本，这种读也被称为当前读（current read）。锁定读会对读取到的记录加锁：
* select ... lock in share mode：对记录加 S 锁，其它事务也可以加 S 锁，如果加 x 锁则会被阻塞
* select ... for update、insert、update、delete：对记录加 X 锁，且其它事务不能加任何锁

#### MVCC 实现原理

在 RC 和 RR 隔离级别下，不显式加 lock in share mode 与 for update 的 select 操作都属于快照读，使用 MVCC，因此，如果想要在一个数据库事务中读取到最新的数据，
要么将隔离级别设置为 RC，要么使用加锁读（即当前读）的方式。

RR 隔离级别下为什么读不到最新的数据？这与 undo log 有关。  
undo log 的作用有两个：  
* 当事务回滚时用于将数据恢复到修改前的样子
* 另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读  

RR 隔离级别下，快照读一个事务中多次 select 也只会开启一个 Read View，即使在多次 select 之间有新的事务提交，新事务的 DB_TRX_ID 也会大于该 Read View 的 m_low_limit_id ，从而该记录行的值
对当前事务不可见，会去到 undo log 中找该记录行的之前的快照记录。

RC 和当前读能读到最新数据是因为，RC 隔离级别下每一个 select 都会新开启一个 Read View，新提交的事务在下一次 select 开始 Read View 时都能感知到。而当前读会对读的数据加锁，如果读的数据正在别的事务中，
则会一直阻塞，直到该事务结束，所以读到的必定时最新的数据。