## 事务概述

### 本地事务

#### 事务特性

* Atomicity-原子性：同一个事务的所有操作，要么全部完成，要么全部不完成
* Consistency-一致性：在事务开始之前和结束之后，数据库的完整性未被破坏（符合预期）
* Isolation-隔离性：可以防止多个事务交叉执行时导致数据不一致；隔离级别由低到高依次为：
    * 读未提交（Read uncommitted）
    * 读已提交（read committed，RC），Oracle 等多数数据库的默认隔离级别
    * 可重复读（repeatable read，RR），Mysql 的默认隔离级别
    * 串行化（Serializable）
* Durability-持久性：事务结束后，对数据的修改就是永久性的

#### InnoDB 事务实现原理

事务的 ACID 是通过 InnoDB 日志和锁来保证。

事务的隔离性是通过数据库锁的机制实现的，持久性通过 redo log（重做日志）来实现，原子性和一致性通过 undo log 来实现。

undo log 的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 undo log）。 然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，系统可以利用
undo log 中的备份将数据恢复到事务开始之前的状态。

和 undo log 相反，redo log 记录的是新数据的备份。在事务提交前，只要将 redo log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化， 但是 redo log 已经持久化。系统可以根据 redo
log 的内容，将所有数据恢复到最新的状态。

### 分布式事务

#### CAP 原则

* Consistency-一致性：更新操作成功后，所有节点在同一时间的数据完全一致
* Availability-可用性：用户访问数据时，系统是否能在正常响应时间返回结果
* Partition tolerance-分区容错性：系统在遇到部分节点或网络分区故障的时候，仍然能够提供满足一致性和可用性的服务

当前普遍认为 CAP 三者只能同时满足其二，而 P 通常是需要保证的（因为节点故障或网络异常难以避免），Zookeeper 选择的是 CP（选举期间无法对外提供服务，即不保证 A）， Eureka 选择的是
AP（选举期间也可以提供服务，但不保证各节点数据完全一致）。

#### BASE 理论

* Basically Available，基本可用
* Soft state，软状态/柔性事务
* Eventual consistency，最终一致性

CAP 中一致性和可用性权衡的结果，既然强一致性难以做到，那退而求其次，只要最终数据是一致的，中间短暂的不一致通常认为是可以忍受的。

[CAP和BASE理论](./CAP和BASE理论.md)

## 分布式事务解决方案

### 2PC

基于 XA 协议，各大主流数据库已有自己的实现。

#### 阶段：

* 第一阶段（prepare）：
    * 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复；
    * 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）；
    * 如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。
* 第二阶段（commit/rollback）：协调者基于各个事务参与者的准备状态，来决策是事务提交 Commit() 或事务回滚 Rollback()。如果协调者收到了参与者的失败消息或者超时，
  直接给每个参与者发送回滚（rollback）消息；否则，发送提交（commit）消息。参与者根据协调者的指令执行提交或者回滚操作， 释放所有事务处理过程中使用的锁资源。（注意：必须在最后阶段释放锁资源）

![](../../images/20220122-1.png)

#### 伪代码

XA 事务，通过 Start 启动一个 XA 事务，并且被置为 Active 状态，处在 active 状态的事务可以执行 SQL 语句，通过 END 方法将 XA 事务置为 IDLE 状态。处于 IDLE 状态可以执行 PREPARE
操作或者 COMMIT…ONE PHASE 操作， 也就是二阶段提交中的第一阶段，PREPARED 状态的 XA事务的时候就可以 Commit 或者 RollBack，也就是二阶段提交的第二阶段。

场景： 模拟现金 + 红包组合支付，假设我们购买了 100 块钱的东西，90块使用现金支付，10 块红包支付，现金和红包处在不同的库。假设：现在有两个库：xa_account(账户库，现金库)、xa_red_account(红包库)。
两个库下面都有一张 account 表，account 表中的字段也比较简单，就 id、user_id、balance_amount 三个字段。

```java
public class XaDemo {
    public static void main(String[] args) throws Exception {
        // 是否开启日志
        boolean logXaCommands = true;

        // 获取账户库的 rm(ap做的事情)
        Connection accountConn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/xa_account?useUnicode=true&characterEncoding=utf8", "root", "xxxxx");
        XAConnection accConn = new MysqlXAConnection((JdbcConnection) accountConn, logXaCommands);
        XAResource accountRm = accConn.getXAResource();

        // 获取红包库的RM
        Connection redConn = DriverManager.getConnection("jdbc:mysql://106.12.12.xxxx:3306/xa_red_account?useUnicode=true&characterEncoding=utf8", "root", "xxxxxx");
        XAConnection Conn2 = new MysqlXAConnection((JdbcConnection) redConn, logXaCommands);
        XAResource redRm = Conn2.getXAResource();

        // XA 事务开始了
        // 全局事务
        byte[] globalId = UUID.randomUUID().toString().getBytes();

        // 就一个标识
        int formatId = 1;

        // 账户的分支事务
        byte[] accBqual = UUID.randomUUID().toString().getBytes();
        ;
        Xid xid = new MysqlXid(globalId, accBqual, formatId);

        // 红包分支事务
        byte[] redBqual = UUID.randomUUID().toString().getBytes();
        ;
        Xid xid1 = new MysqlXid(globalId, redBqual, formatId);

        try {
            // 账号事务开始 此时状态：ACTIVE
            accountRm.start(xid, XAResource.TMNOFLAGS);
            // 模拟业务
            String sql = "update account set balance_amount=balance_amount-90 where user_id=1";
            PreparedStatement ps1 = accountConn.prepareStatement(sql);
            ps1.execute();
            accountRm.end(xid, XAResource.TMSUCCESS);

            // 红包分支事务开始
            redRm.start(xid1, XAResource.TMNOFLAGS);
            // 模拟业务
            String sql1 = "update account set balance_amount=balance_amount-10 where user_id=1";
            PreparedStatement ps2 = redConn.prepareStatement(sql1);
            ps2.execute();
            redRm.end(xid1, XAResource.TMSUCCESS);
            // XA 事务 此时状态：PREPARED  
            // 第二阶段：TM 根据第一阶段的情况决定是提交还是回滚
            boolean onePhase = false; //TM判断有2个事务分支，所以不能优化为一阶段提交
            if (rm1_prepare == XAResource.XA_OK && rm2_prepare == XAResource.XA_OK) {
                accountRm.commit(xid, onePhase);
                redRm.commit(xid1, onePhase);
            } else {
                accountRm.rollback(xid);
                redRm.rollback(xid1);
            }
        } catch (Exception e) {
            // 出现异常，回滚
            accountRm.rollback(xid);
            redRm.rollback(xid1);
            e.printStackTrace();
        }
    }
}
```

#### 缺点：

* 性能：在阶段一需要所有的参与者都返回状态后才能进入第二阶段，并且要把相关的全局资源锁定住，这种同步阻塞的操作，会影响整体事务的并发度；
* 可靠性：如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态；
* 数据不一致：在二阶段提交的阶段中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了 commit 请求。 而在这部分参与者接到
  commit 请求之后就会执行 commit 操作，但是其他未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。

### 3PC

相比于二阶提交（2PC）多了一个预提交阶段，同时协调者和参与者都引入超时机制。

**多出来的阶段其实是将 2PC 中的 prepare 阶段拆分为 CanCommit 和 PreCommit 两个阶段。CanCommit 阶段询问是否可以完成本次事务，PreCommit 阶段 记录 undo log 和 redo
log，并协调者反馈是否准备好。**

#### 阶段：

第一阶段（CanCommit 阶段）：是一种事务询问操作，事务的协调者向所有参与者询问“**你们是否可以完成本次事务？**”，如果参与者节点认为自身可以完成事务就返回 YES，否则
NO。而在实际的场景中参与者节点会对自身逻辑进行事务尝试，其实说白了就是检查下自身状态的健康性，看有没有能力进行事务操作。

![](../../images/20220125-1.jpeg)

第二阶段（PreCommit 阶段）：在阶段一中，如果所有的参与者都返回 Yes 的话，那么就会进入 PreCommit 阶段进行事务预提交。此时分布式事务协调者会向所有的参与者节点发送 PreCommit
请求，参与者收到后开始执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈"Ack"表示我已经准备好提交了， 并等待协调者的下一步指令。

![](../../images/20220125-2.jpeg)

第三阶段（DoCommit阶段）：在阶段二中如果所有的参与者节点都可以进行 PreCommit 提交，那么协调者就会从“预提交状态”->“提交状态”。然后向所有的参与者节点发送"doCommit"
请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈"Ack"消息，协调者收到所有参与者的"Ack"消息后完成事务。

相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。

![](../../images/20220125-3.jpeg)

#### 对比 2PC

* 首先引入了超时机制避免事务长时间阻塞；
* 多一个环节，性能稍差；
* 依然存在数据不一致问题。

### TCC

TCC 本质上是一个业务层面上的 2PC，他要求业务在使用TCC模式时必须实现三个接口 Try()、Confirm() 和 Cancel()。2PC无法解决宕机问题，那 TCC 如何解决 2PC 无法应对宕机问题的缺陷的呢？答案是不断重试。

TCC 和 2PC 看起来很像，TCC 和 2PC 最大的区别是，2PC 是偏数据库层面的，而 TCC 是纯业务层面。

#### 阶段

![](../../images/20220125-6.png)

TCC 是服务化的二阶段编程模型，其 Try、Confirm、Cancel 3 个方法均由业务编码实现：

* Try 操作作为一阶段，负责资源的检查和预留；
* Confirm 操作作为二阶段提交操作，执行真正的业务；
* Cancel 是预留资源的取消。

##### Try 阶段

Try 仅是一个初步操作，它和后续的 Confirm 一起才能真正构成一个完整的业务逻辑（可以理解为 Try 阶段只完成了业务逻辑的一部分，剩下的一部分交由 Confirm 阶段完成）。

这个阶段主要完成：

* 完成所有业务检查(一致性)；
* 预留必须业务资源(准隔离性)；
* Try 尝试执行业务。

假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。

![](../../images/20220125-4.png)

##### Confirm/Cancel 阶段

根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。

Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。

Confirm：当 Try 阶段服务全部正常执行，执行确认业务逻辑操作。

![](../../images/20220125-5.awebp)

这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。

Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。 这里 Confirm 阶段的逻辑是把 Try 阶段保存的冻结库存减 2，同时修改 Try 阶段创建的订单状态为"成功"，
代表完成了整个业务。

Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段。

![](../../images/20220125-7.awebp)

Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，恢复库存，并更新订单状态为取消。

#### 设计要点

##### 空回滚

如果协调者的 Try() 请求因为网络超时失败，那么协调者在阶段二时会发送 Cancel() 请求，而这时这个事务参与者实际上之前并没有执行 Try() 操作而直接收到了 Cancel() 请求。

针对这个问题，TCC 模式要求在这种情况下 Cancel() 能直接返回成功，也就是要允许「空回滚」。

##### 防悬挂

接着上面的问题 1，Try() 请求超时，事务参与者收到 Cancel() 请求而执行了空回滚，但就在这之后网络恢复正常，事务参与者又收到了这个 Try() 请求，所以 Try() 和 Cancel()
发生了悬挂，也就是先执行了 Cancel() 后又执行了 Try()。针对这个问题，TCC 模式要求在这种情况下，事务参与者要记录下 Cancel() 的事务ID，当发现 Try() 的事务 ID 已经被回滚，则直接忽略掉该请求。

##### 幂等性

Confirm() 和 Cancel() 的实现必须是幂等的。当这两个操作执行失败时协调者都会发起重试。

#### 代码实现逻辑

1. 初始化：向事务管理器注册新事务，生成全局事务唯一 ID；
2. try 阶段执行：try 相关的代码执行，期间注册相应的调用记录，发送 try 执行结果到事务管理器，执行成功由事务管理器执行 confirm 或者 cancel 步骤；
3. confirm 阶段：事务管理器收到 try 执行成功信息，根据事务 ID，进入事务 confirm 阶段执行，confirm 失败进入 cancel，成功则结束;
4. cancel 阶段：事务管理器收到 try 执行失败或者 confirm 执行失败，根据事务 ID，进入 cancel 阶段执行后结束，如果失败了，打印日志或者告警，让人工参与处理，也可记录失败，系统不断对 cancel 进行重试。

#### 总结

相比于 2PC 具有如下优势：

* 性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源；
* 数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性；
* 可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群；
* 支持度：该模式对有无本地事务控制都可以支持使用面广。**2PC 依赖于数据库本身的事务利用 undo log 进行回滚，而 TCC 在业务层面，定义好补偿方法， 在需要回滚时调用，所以不依赖本地事务。由于不依赖事务，所以 TCC
  的中，多步骤的操作应该拆分为多个事务分支。**

缺点：TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。

### SEGA

### 本地消息表

## 分布式事务框架

### Seata

#### 各事务模式

##### Seata AT 模式

undo_log 表会在二阶段提交（commit/roll back）完成时清空，所以正常情况下无法看见 undo_log 表中的记录。