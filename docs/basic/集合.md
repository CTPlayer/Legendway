## Collection 接口下的集合

### List

* ArrayList  
  基于数组，非线程安全；  
  插入和删除元素的时间复杂度受元素位置的影响，在指定位置 i 插入和删除元素的话，集合中第 i 和第 i 个元素之后的 (n-i) 个元素都要执行向后位/向前移一位的操作；  
  支持快速随机访问；  
  ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间(待理解)；
* Vector  
  基于数组，古老实现，线程安全，不建议使用。
* LinkedList  
  基于双向链表，非线程安全；  
  如果是在头尾插入或者删除元素不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插入和删除元素的话， 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入；  
  不支持快速随机访问；  
  LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）；

### Set

* HashSet
* LinkedHashSet
* TreeSet

## Map 接口下的集合

### Map

* HashMap  
  非线程安全；  
  HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；  
  HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，
  就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同的话则通过相应方法解决冲突；      
  JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）；  
  JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于
  64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间；  
  HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍；    
  进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize；
* LinkedHashMap   
  参考链接：<https://www.imooc.com/article/22931>  
  LinkedHashMap 继承自 HashMap，在 HashMap 基础上，通过维护一条双向链表，解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题；  
  ![20210625-1.png](../../images/20210625-1.png)  
  链表的建立过程：链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail
  引用指向节点的后面，即可实现链表的更新（访问时从头到位遍历链表访问）；  
  访问顺序的维护过程：默认情况下，LinkedHashMap 是按插入顺序维护链表。不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表。原理是当我们调用
  get/getOrDefault/replace 等方法时，只需要将这些方法访问的节点移动到链表的尾部；  
  基于 LinkedHashMap 实现 LRU 策略缓存：
  ```java
  void afterNodeInsertion(boolean evict) { // possibly remove eldest
      LinkedHashMap.Entry<K,V> first;
      // 根据条件判断是否移除最近最少被访问的节点
      if (evict && (first = head) != null && removeEldestEntry(first)) {
          K key = first.key;
          removeNode(hash(key), key, null, false, true);
      }
  }

  // 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存
  protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
      return false;
  }
  ```  
  当我们基于 LinkedHashMap 实现缓存时，通过覆写 removeEldestEntry 方法可以实现自定义策略的 LRU
  缓存。比如我们可以根据节点数量判断是否移除最近最少被访问的节点，或者根据节点的存活时间判断是否移除该节点等;   
  实现代码如下：
  ```java
  public class SimpleCache<K, V> extends LinkedHashMap<K, V> {

      private static final int MAX_NODE_NUM = 100;
  
      private int limit;
  
      public SimpleCache() {
          this(MAX_NODE_NUM);
      }
  
      public SimpleCache(int limit) {
          super(limit, 0.75f, true);
          this.limit = limit;
      }
  
      public V save(K key, V val) {
          return put(key, val);
      }
  
      public V getOne(K key) {
          return get(key);
      }
  
      public boolean exists(K key) {
          return containsKey(key);
      }
  
      /**
       * 判断节点数是否超限
       * @param eldest
       * @return 超限返回 true，否则返回 false
       */
      @Override
      protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
          return size() > limit;
      }
  }
  ```
* HashTable
* TreeMap
* ConcurrentHashMap

## 补充

* RandomAccess 接口
  ```java
  public interface RandomAccess {
  }
  ```
  RandomAccess 接口只是标识，标识实现这个接口的类具有随机访问功能。ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现（和他们的底层数据结构有关，并不是说 ArrayList 实现
  RandomAccess 接口才具有快速随机访问功能的！）。

