### 动态绑定
动态绑定是指在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。例如方法接受基类参数，实际传入导出类作为参数，则程序在运行时才确定被
调用的代码。
在Java中，动态绑定时默认行为，不需要添加额外的关键字来实现多态。

### this关键字
this关键字只能在方法内部使用，表示对"调用方法的那个对象"的引用。  
通常写this的时候，都是指"这个对象"或者"当前对象"，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有了不同的含义。这将产生对符合此
参数列表的某个构造器的明确调用。

### 自动装箱
它允许程序员将基本类型和装箱基本类型混用，按需自动装箱和拆箱。它们之间的差别变得模糊，但是并没有完全的消除。除了语意上有微妙的差别，在性能上也有着明显的差别。
```java
public static void main(String[] args) {
    Long sum = 0L;
    for (int i = 0;i < Integer.MAX_VALUE;i ++) {
        sum += i;
    }
    System.out.println(sum);   
}
```
变量sum被声明成Long而不是long，意味着程序每次往Long sum中增加long时构造一个实例。所以结论很明显：要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。

### ++i与i++
++i等同于i = i + 1
++i: 先执行运算，再生成值  
![avatar](../../images/20210331-1.png)  
i++: 先生成值，再执行运算  
![avatar](../../images/20210331-2.png)

### 标签（label）
在Java中，标签起作用的唯一地方刚好是在迭代语句之前。“刚好之前”的意思表明，在标签和迭代之间置入任和语句都不好。
在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。

### equals与hashCode
默认情况下，类的实例只与它自生相等。  
Object的hashCode方法是本地方法，也就是用c语言或c++实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

**为什么重写equals时必须重写hashCode方法？** 如果两个对象相等，则hashCode一定也是相同的。hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写
hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

### static关键字
静态域只有在所属类的第一个对象被创建或者第一次访问该类的静态域时，才会被初始化。此后，静态域不会再次被初始化。访问类的一个静态域，该类的所有静态域都会被初始化。简而言之静态
初始化只在Class对象首次加载的时候进行一次。